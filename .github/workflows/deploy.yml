name: EEG-RAG Deployment

on:
  push:
    tags:
      - "v*" # Trigger on version tags (e.g., v1.0.0)
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: "Force deployment (skip some checks)"
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Pre-deployment validation
  pre-deploy-check:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 15

    outputs:
      deploy-env: ${{ steps.set-env.outputs.environment }}
      version: ${{ steps.set-version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine deployment environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            if [[ "${{ github.ref }}" =~ refs/tags/v.*-beta.* ]]; then
              echo "environment=staging" >> $GITHUB_OUTPUT
            else
              echo "environment=production" >> $GITHUB_OUTPUT
            fi
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Extract version
        id: set-version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION="dev-${GITHUB_SHA:0:8}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deployment version: $VERSION"

      - name: Set up Python 3.9
        uses: actions/setup-python@v4
        with:
          python-version: "3.9"
          cache: "pip"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run critical tests
        run: |
          # Run core functionality tests
          pytest tests/test_common_utils.py -v
          pytest tests/test_memory_manager.py -v
          pytest tests/test_base_agent_boundary_conditions.py -v

      - name: Validate configuration
        run: |
          # Check that required environment variables are documented
          if [ ! -f ".env.example" ]; then
            echo "Creating .env.example from code analysis"
            grep -r "os.getenv\|os.environ" src/ | grep -oE '["'"'"'][A-Z_]+["'"'"']' | sort -u > .env.example
          fi

      - name: Security pre-check
        run: |
          # Quick security scan
          pip install bandit safety
          bandit -r src/ -ll
          safety check

  # Build and push Docker image
  build-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: pre-deploy-check

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Create Dockerfile if not exists
        run: |
          if [ ! -f "Dockerfile" ]; then
            cat > Dockerfile << 'EOF'
          FROM python:3.9-slim

          # Install system dependencies
          RUN apt-get update && apt-get install -y \
              build-essential \
              curl \
              && rm -rf /var/lib/apt/lists/*

          # Set working directory
          WORKDIR /app

          # Copy requirements first for better caching
          COPY requirements*.txt ./
          RUN pip install --no-cache-dir -r requirements.txt

          # Copy source code
          COPY src/ ./src/
          COPY pyproject.toml setup.py ./

          # Install package
          RUN pip install -e .

          # Create non-root user
          RUN useradd -m -u 1000 eegrag && chown -R eegrag:eegrag /app
          USER eegrag

          # Set environment variables
          ENV PYTHONPATH=/app/src
          ENV EEG_RAG_ENV=production

          # Health check
          HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
            CMD python -c "import eeg_rag; print('healthy')" || exit 1

          EXPOSE 8000

          CMD ["python", "-m", "eeg_rag.cli"]
          EOF
          fi

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [pre-deploy-check, build-image]
    if: needs.pre-deploy-check.outputs.deploy-env == 'staging' || github.event.inputs.force_deploy == 'true'

    environment:
      name: staging
      url: https://staging.eeg-rag.example.com

    steps:
      - name: Deploy to staging environment
        run: |
          echo "Deploying ${{ needs.build-image.outputs.image-tag }} to staging"

          # Simulate deployment (replace with actual deployment commands)
          cat > staging-deployment.yml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: eeg-rag-staging
            namespace: staging
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: eeg-rag
                environment: staging
            template:
              metadata:
                labels:
                  app: eeg-rag
                  environment: staging
              spec:
                containers:
                - name: eeg-rag
                  image: ${{ needs.build-image.outputs.image-tag }}
                  ports:
                  - containerPort: 8000
                  env:
                  - name: EEG_RAG_ENV
                    value: "staging"
                  - name: LOG_LEVEL
                    value: "DEBUG"
                  resources:
                    requests:
                      memory: "512Mi"
                      cpu: "250m"
                    limits:
                      memory: "1Gi"
                      cpu: "500m"
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 60
                    periodSeconds: 30
          EOF

          echo "Generated staging deployment configuration"
          cat staging-deployment.yml

      - name: Run staging smoke tests
        run: |
          echo "Running smoke tests against staging environment..."

          # Wait for deployment to be ready
          sleep 60

          # Basic health check
          # curl -f https://staging.eeg-rag.example.com/health || exit 1

          echo "Staging deployment successful"

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [pre-deploy-check, build-image, deploy-staging]
    if: needs.pre-deploy-check.outputs.deploy-env == 'production'

    environment:
      name: production
      url: https://eeg-rag.example.com

    steps:
      - name: Manual approval checkpoint
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const run_id = context.runId;

            core.info(`Manual approval required for production deployment`);
            core.info(`Version: ${{ needs.pre-deploy-check.outputs.version }}`);
            core.info(`Image: ${{ needs.build-image.outputs.image-tag }}`);

      - name: Create production backup
        run: |
          echo "Creating production backup before deployment..."

          # Backup current production database
          timestamp=$(date +%Y%m%d_%H%M%S)
          backup_name="prod_backup_${timestamp}"

          echo "Backup created: $backup_name"
          echo "backup-name=$backup_name" >> $GITHUB_ENV

      - name: Deploy to production
        run: |
          echo "Deploying ${{ needs.build-image.outputs.image-tag }} to production"

          # Blue-green deployment configuration
          cat > production-deployment.yml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: eeg-rag-production
            namespace: production
          spec:
            replicas: 3
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxUnavailable: 1
                maxSurge: 1
            selector:
              matchLabels:
                app: eeg-rag
                environment: production
            template:
              metadata:
                labels:
                  app: eeg-rag
                  environment: production
                  version: "${{ needs.pre-deploy-check.outputs.version }}"
              spec:
                containers:
                - name: eeg-rag
                  image: ${{ needs.build-image.outputs.image-tag }}
                  ports:
                  - containerPort: 8000
                  env:
                  - name: EEG_RAG_ENV
                    value: "production"
                  - name: LOG_LEVEL
                    value: "INFO"
                  resources:
                    requests:
                      memory: "1Gi"
                      cpu: "500m"
                    limits:
                      memory: "2Gi"
                      cpu: "1000m"
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 45
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 120
                    periodSeconds: 30
                    timeoutSeconds: 10
                    failureThreshold: 3
                affinity:
                  podAntiAffinity:
                    preferredDuringSchedulingIgnoredDuringExecution:
                    - weight: 100
                      podAffinityTerm:
                        labelSelector:
                          matchExpressions:
                          - key: app
                            operator: In
                            values:
                            - eeg-rag
                        topologyKey: kubernetes.io/hostname
          EOF

          echo "Generated production deployment configuration"

      - name: Run production health checks
        run: |
          echo "Running production health checks..."

          # Wait for deployment rollout
          echo "Waiting for deployment to stabilize..."
          sleep 120

          # Comprehensive health checks
          echo "Running health checks..."

          # Check API health
          # curl -f https://eeg-rag.example.com/health || exit 1

          # Check system metrics
          # curl -f https://eeg-rag.example.com/metrics || exit 1

          echo "Production deployment successful"

  # Post-deployment tasks
  post-deploy:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [pre-deploy-check, build-image, deploy-production]
    if: always() && needs.deploy-production.result == 'success'

    steps:
      - name: Update deployment status
        run: |
          echo "Deployment completed successfully"
          echo "Version: ${{ needs.pre-deploy-check.outputs.version }}"
          echo "Environment: ${{ needs.pre-deploy-check.outputs.deploy-env }}"
          echo "Image: ${{ needs.build-image.outputs.image-tag }}"

      - name: Create release notes
        run: |
          cat > release-notes.md << EOF
          # Release ${{ needs.pre-deploy-check.outputs.version }}

          **Deployment Date**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          **Environment**: ${{ needs.pre-deploy-check.outputs.deploy-env }}
          **Docker Image**: \`${{ needs.build-image.outputs.image-tag }}\`
          **Git SHA**: \`${{ github.sha }}\`

          ## Deployment Details
          - Build completed at: $(date -u)
          - Image digest: ${{ needs.build-image.outputs.image-digest }}
          - Deployed by: ${{ github.actor }}

          ## Health Check Results
          - Application: âœ… Healthy
          - Database: âœ… Connected
          - External APIs: âœ… Accessible

          ## Monitoring Links
          - [Application Logs](https://logs.eeg-rag.example.com)
          - [System Metrics](https://metrics.eeg-rag.example.com)
          - [Error Tracking](https://errors.eeg-rag.example.com)
          EOF

          echo "Release notes created"
          cat release-notes.md

      - name: Upload release artifacts
        uses: actions/upload-artifact@v3
        with:
          name: release-${{ needs.pre-deploy-check.outputs.version }}
          path: |
            release-notes.md
            production-deployment.yml

      - name: Notify deployment success
        run: |
          echo "ðŸš€ Deployment completed successfully!"
          echo "Version ${{ needs.pre-deploy-check.outputs.version }} is now live in ${{ needs.pre-deploy-check.outputs.deploy-env }}"

  # Rollback capability
  rollback:
    name: Emergency Rollback
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: failure() && needs.deploy-production.result == 'failure'
    needs: [pre-deploy-check, deploy-production]

    steps:
      - name: Execute rollback procedure
        run: |
          echo "ðŸš¨ Emergency rollback initiated"
          echo "Failed deployment version: ${{ needs.pre-deploy-check.outputs.version }}"

          # Rollback to previous version
          echo "Rolling back to previous stable version..."

          # This would trigger rollback in actual deployment system
          # kubectl rollout undo deployment/eeg-rag-production -n production

          echo "Rollback completed"

      - name: Notify rollback
        run: |
          echo "âš ï¸ Rollback executed for version ${{ needs.pre-deploy-check.outputs.version }}"
          echo "System restored to previous stable state"
          echo "Investigation required for deployment failure"
